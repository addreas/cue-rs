// https://cuelang.org/docs/references/spec/
// https://review.gerrithub.io/c/cue-lang/cue/+/540569/3/doc/ref/spec.md#458
// "Production names starting with an uppercase Unicode letter denote non-terminal productions (i.e., productions which allow white-space and comments between tokens); all other production names denote lexical productions."
// https://pest.rs/book/grammars/syntax.html#atomic

newline        = _{ "\u{000A}" }
dq             = _{ "\"" }
sq             = _{ "'" }
unicode_char   = _{ !newline ~ ANY }
unicode_letter = _{ LETTER }
unicode_digit  = _{ DECIMAL_NUMBER }

letter        = _{ unicode_letter | "_" | "$" }
decimal_digit = _{ '0'..'9' }
binary_digit  = _{ '0'..'1' }
octal_digit   = _{ '0'..'7' }
hex_digit     = _{ '0'..'9' | 'A'..'F' | 'a'..'f' }

identifier = @{ ("#" | "_#")? ~ letter ~ (letter | unicode_digit)* }

decimal_lit = @{ "0" | ("-"? ~ '1'..'9' ~ ( "_"? ~ decimal_digit )*) }
fraction    = @{ decimal_digit ~ ( "_"? ~ decimal_digit )* }
si_lit      = ${ (decimal_lit ~ ("." ~  fraction)? ~ multiplier)
               | ("." ~ fraction ~  multiplier)
               }
binary_lit  = @{ "0b" ~ binary_digit ~ ( "_"? ~ binary_digit )* }
octal_lit   = @{ "0o" ~ octal_digit ~ ( "_"? ~ octal_digit )* }
hex_lit     = @{ "0" ~ ( "x" | "X" ) ~ hex_digit ~ ("_"? ~ hex_digit )* }
multiplier  = @{ ("K" | "M" | "G" | "T" | "P" ) ~ "i"? }
exponent    = ${ ("e" | "E") ~ decimal_lit}

int_lit     = ${ si_lit | decimal_lit  | octal_lit | binary_lit | hex_lit }
float_lit   = ${ (decimal_lit ~ ("." ~ fraction)? ~ exponent?)
               | ("." ~ fraction ~ exponent? )
               }

escaped_char     = @{ "\\" ~ PEEK ~ ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | "/" | "\\" | sq | dq ) }
octal_byte_value = @{ "\\" ~ PEEK ~ octal_digit{3} }
hex_byte_value   = @{ "\\" ~ PEEK ~ "x" ~ hex_digit{2} }
little_u_value   = @{ "\\" ~ PEEK ~ "u" ~ hex_digit{4} }
big_u_value      = @{ "\\" ~ PEEK ~ "U" ~ hex_digit{8} }
Interpolation    = !{ "\\" ~ PEEK ~ "(" ~ Expression ~ ")" }
unicode_value    = @{ unicode_char | little_u_value | big_u_value | escaped_char }
byte_value       = @{ octal_byte_value | hex_byte_value }

String       = { PUSH("#"*) ~ ( SimpleString
                               | MultilineString
                               | SimpleBytes
                               | MultilineBytes
                               ) ~ POP }

SimpleString    = { dq ~ ( unicode_value | Interpolation )* ~ dq }
SimpleBytes     = { sq ~ ( unicode_value | Interpolation | byte_value )* ~ sq }
MultilineString = { dq{3}
                  ~ newline
                  ~ ( unicode_value | Interpolation | newline )*
                  ~ newline
                  ~ dq{3} }
MultilineBytes  = { sq{3}
                  ~ newline
                  ~ ( unicode_value | Interpolation | byte_value | newline )*
                  ~ newline
                  ~ sq{3} }

bottom_lit = { "_|_" }
null_lit   = { "null" }
bool_lit   = { "true" | "false" }

StructLit       = { "{" ~ ( Declaration ~ "," )* ~ "}" }
Declaration     = { Field | Ellipsis | Embedding | attribute }
Ellipsis        = { "..." ~ Expression? }
Embedding       = { Comprehension | AliasExpr }
Field           = { Label ~ ":" ~ ( Label ~ ":" )* ~ AliasExpr ~ attribute* }
Label           = { ( identifier ~ "=" ) ~ LabelExpr }
LabelExpr       = { ( LabelName ~ "?"? )
                  | ( "[" ~ AliasExpr ~ "]" )
                  | ( "(" ~ AliasExpr ~ ")" )
                  }
LabelName       = { identifier | SimpleString  }

attribute       = @{ "@" ~ identifier ~ "(" ~ attr_tokens ~ ")" }
attr_tokens     = @{ ( attr_token
                     | ( "(" ~ attr_tokens ~ ")" )
                     | ( "[" ~ attr_tokens ~ "]" )
                     | ( "{" ~ attr_tokens ~ "}" )
                     )* }
attr_token      = @{ !( "(" | ")" | "[" | "]" | "{" | "}" ) ~ ANY }

AliasExpr  = { ( identifier ~ "=" )? ~ Expression }

ListLit       = { "[" ~ ( ElementList ~ ","? )? ~ "]" }
ElementList   = { Ellipsis | ( Embedding ~ ( "," ~ Embedding )* ~ ( "," ~ Ellipsis )? ) }

Literal     = { BasicLit | ListLit | StructLit }
Operand     = { Literal | OperandName | ( "(" ~ Expression ~ ")" ) }
BasicLit    = { float_lit | int_lit | String | null_lit | bool_lit | bottom_lit }
OperandName = { identifier | QualifiedIdent }

QualifiedIdent = { PackageName ~ "." ~ identifier }

Selector       = { "." ~ ( identifier | SimpleString ) }
Index          = { "[" ~ Expression ~ "]" }
Slice          = { "[" ~ Expression? ~ ":" ~ Expression? ~ "]" }
Argument       = { Expression }
Arguments      = { "(" ~ ( ( Argument ~ ( "," ~ Argument )* ) ~ ","? )? ~ ")" }

// PrimaryExpr = {	Operand
//               | ( PrimaryExpr ~ Selector )
//               | ( PrimaryExpr ~ Index )
//               | ( PrimaryExpr ~ Slice )
//               | ( PrimaryExpr ~ Arguments )
//               }

PrimaryExpr = { Operand ~ (Selector | Index | Slice | Arguments )* }

UnaryExpr  = { PrimaryExpr | ( unary_op ~ UnaryExpr ) }
// Expression = { UnaryExpr | ( Expression ~ binary_op ~ Expression ) }
Expression = { UnaryExpr ~ (binary_op ~ Expression)? }


binary_op  = { "|" | "&" | "||" | "&&" | "==" | rel_op | add_op | mul_op  }
rel_op     = { "!=" | "<" | "<=" | ">" | ">=" | "=~" | "!~" }
add_op     = { "+" | "-" }
mul_op     = { "*" | "/" }
unary_op   = { "+" | "-" | "!" | "*" | rel_op }

Comprehension = { Clauses ~ StructLit }

Clauses       = { StartClause ~ ( ","? ~ Clause )* }
StartClause   = { ForClause | GuardClause }
Clause        = { StartClause | LetClause }
ForClause     = { "for" ~ identifier ~ ( "," ~ identifier )? ~ "in" ~ Expression }
GuardClause   = { "if" ~ Expression }
LetClause     = { "let" ~ identifier ~ "=" ~ Expression }

PackageClause = { "package" ~ PackageName }
PackageName   = { identifier }

ImportDecl     = { "import" ~ ( ImportSpec | ("(" ~ ImportSpec* ~ ")") ) }
ImportSpec     = { PackageName? ~ ImportPath }
ImportLocation = { unicode_value }
ImportPath     = { "\"" ~ ImportLocation ~ (":" ~ identifier)? ~ "\"" }

SourceFile = { SOI 
             ~ (attribute ~ ",")*
             ~ (PackageClause)?
             ~ (ImportDecl)*
             ~ (Declaration)*
             ~ EOI
             }

WHITESPACE = _{ " " | "\t" | "\n" }
COMMENT = _{ "//" ~ (!newline ~ ANY)* ~ (newline | EOI) }
