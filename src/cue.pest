newline        = _{ "\u{000A}" }
dq             = _{ "\"" }
sq             = _{ "'" }
unicode_char   = _{ !newline ~ ANY }
unicode_letter = _{ LETTER }
unicode_digit  = _{ DECIMAL_NUMBER }

letter        = _{ unicode_letter | "_" | "$" }
decimal_digit = _{ '0'..'9' }
binary_digit  = _{ '0'..'1' }
octal_digit   = _{ '0'..'7' }
hex_digit     = _{ '0'..'9' | 'A'..'F' | 'a'..'f' }

identifier = _{ ("#" | "_#")? ~ letter ~ (letter | unicode_digit)* }

decimals    = _{ decimal_digit ~ ( "_"? ~ decimal_digit )* }
si_lit      = _{ (decimals ~ ("." ~  decimals)? ~ multiplier)
               | ("." ~ decimals ~  multiplier)
               }
binary_lit  = _{ "0b" ~ binary_digit ~ ( "_"? ~ binary_digit )* }
octal_lit   = _{ "0o" ~ octal_digit ~ ( "_"? ~ octal_digit )* }
hex_lit     = _{ "0" ~ ( "x" | "X" ) ~ hex_digit ~ ("_"? ~ hex_digit )* }
multiplier  = _{ ("K" | "M" | "G" | "T" | "P" ) ~ "i"? }
exponent    = _{ ("e" | "E") ~ ("+" | "-")? ~ decimals}

int_lit     = _{ decimals | si_lit | octal_lit | binary_lit | hex_lit }
float_lit = _{ (decimals ~ "." ~ decimals? ~ exponent?)
             | (decimals ~ exponent)
             | ("." ~ decimals ~ exponent? )
             }

escaped_char     = _{ "\\" ~ PEEK ~ ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | "/" | "\\" | sq | dq ) }
octal_byte_value = _{ "\\" ~ PEEK ~ octal_digit{3} }
hex_byte_value   = _{ "\\" ~ PEEK ~ "x" ~ hex_digit{2} }
little_u_value   = _{ "\\" ~ PEEK ~ "u" ~ hex_digit{4} }
big_u_value      = _{ "\\" ~ PEEK ~ "U" ~ hex_digit{8} }
interpolation    = !{ "\\" ~ PEEK ~ "(" ~ Expression ~ ")" }
unicode_value    = _{ unicode_char | little_u_value | big_u_value | escaped_char }
byte_value       = _{ octal_byte_value | hex_byte_value }

string_lit       = @{ PUSH("#"*) ~ ( simple_string_lit
                                   | multiline_string_lit
                                   | simple_bytes_lit
                                   | multiline_bytes_lit
                                   ) ~ POP }

simple_string_lit    = _{ dq ~ ( unicode_value | interpolation )* ~ dq }
simple_bytes_lit     = _{ sq ~ ( unicode_value | interpolation | byte_value )* ~ sq }
multiline_string_lit = _{ dq{3}
                        ~ newline
                        ~ ( unicode_value | interpolation | newline )*
                        ~ newline
                        ~ dq{3} }
multiline_bytes_lit  = _{ sq{3}
                        ~ newline
                        ~ ( unicode_value | interpolation | byte_value | newline )*
                        ~ newline
                        ~ sq{3} }

bottom_lit = _{ "_|_" }
null_lit   = _{ "null" }
bool_lit   = _{ "true" | "false" }

StructLit       = { "{" ~ ( Declaration ~ "," )* ~ "}" }
Declaration     = { Field | Ellipsis | Embedding | LetClause | attribute }
Ellipsis        = { "..." ~ Expression? }
Embedding       = { Comprehension | AliasExpr }
Field           = { Label ~ ":" ~ ( Label ~ ":" )* ~ AliasExpr ~ attribute* }
Label           = { ( identifier ~ "=" ) ~ LabelExpr }
LabelExpr       = { ( LabelName ~ "?"? ) | ( "[" ~ AliasExpr ~ "]" ) }
LabelName       = { identifier | simple_string_lit  }

attribute       = _{ "@" ~ identifier ~ "(" ~ attr_tokens ~ ")" }
attr_tokens     = _{ (        attr_token 
                     | ( "(" ~ attr_tokens ~ ")" )
                     | ( "[" ~ attr_tokens ~ "]" )
                     | ( "{" ~ attr_tokens ~ "}" )
                     )* }
attr_token      = _{ !( "(" | ")" | "[" | "]" | "{" | "}" ) ~ ANY }

AliasExpr  = { ( identifier ~ "=" )? ~ Expression }

ListLit       = { "[" ~ ( ElementList ~ ","? )? ~ "]" }
ElementList   = { Ellipsis | ( Embedding ~ ( "," ~ Embedding )* ~ ( "," ~ Ellipsis )? ) }

Literal     = { BasicLit | ListLit | StructLit }
Operand     = { Literal | OperandName | ( "(" ~ Expression ~ ")" ) }
BasicLit    = { int_lit | float_lit | string_lit | null_lit | bool_lit | bottom_lit }
OperandName = { identifier | QualifiedIdent }

QualifiedIdent = { PackageName ~ "." ~ identifier }

Selector       = { "." ~ (identifier | simple_string_lit) }
Index          = { "[" ~ Expression ~ "]" }
Slice          = { "[" ~ Expression? ~ ":" ~ Expression? ~ "]" }
Argument       = { Expression }
Arguments      = { "(" ~ ( ( Argument ~ ( "," ~ Argument )* ) ~ ","? )? ~ ")" }

PrimaryExpr = {	Operand
              | ( PrimaryExpr ~ Selector )
              | ( PrimaryExpr ~ Index )
              | ( PrimaryExpr ~ Slice )
              | ( PrimaryExpr ~ Arguments )
              }

UnaryExpr  = { PrimaryExpr | ( unary_op ~ UnaryExpr ) }
Expression = { UnaryExpr | ( Expression ~ binary_op ~ Expression ) }

binary_op  = { "|" | "&" | "||" | "&&" | "==" | rel_op | add_op | mul_op  }
rel_op     = { "!=" | "<" | "<=" | ">" | ">=" | "=~" | "!~" }
add_op     = { "+" | "-" }
mul_op     = { "*" | "/" }
unary_op   = { "+" | "-" | "!" | "*" | rel_op }

Comprehension = { Clauses ~ StructLit }

Clauses       = { StartClause ~ ( ","? ~ Clause )* }
StartClause   = { ForClause | GuardClause }
Clause        = { StartClause | LetClause }
ForClause     = { "for" ~ identifier ~ ( "," ~ identifier )? ~ "in" ~ Expression }
GuardClause   = { "if" ~ Expression }
LetClause     = { "let" ~ identifier ~ "=" ~ Expression }

PackageClause = { "package" ~ PackageName }
PackageName   = { identifier }

ImportDecl     = { "import" ~ ( ImportSpec | ("(" ~ ImportSpec* ~ ")") ) }
ImportSpec     = { PackageName? ~ ImportPath }
ImportLocation = { unicode_value }
ImportPath     = { "\"" ~ ImportLocation ~ (":" ~ identifier)? ~ "\"" }

SourceFile = { SOI 
    ~ (attribute ~ ",")*
    ~ (PackageClause)?
    ~ (ImportDecl)
    ~ (Declaration)*
    ~ EOI}

COMMENT = _{ "//" ~ (!newline ~ ANY)* ~ newline }
