// https://cuelang.org/docs/references/spec/
// https://review.gerrithub.io/c/cue-lang/cue/+/540569/3/doc/ref/spec.md#458
// "Production names starting with an uppercase Unicode letter denote non-terminal productions (i.e., productions which allow white-space and comments between tokens); all other production names denote lexical productions."
// https://pest.rs/book/grammars/syntax.html#atomic

newline        = { "\u{000A}" }
unicode_char   = { !newline ~ ANY }
unicode_letter = _{ LETTER }
unicode_digit  = _{ DECIMAL_NUMBER }

letter        = _{ unicode_letter | "_" | "$" }
decimal_digit = _{ '0'..'9' }
binary_digit  = _{ '0'..'1' }
octal_digit   = _{ '0'..'7' }
hex_digit     = _{ '0'..'9' | 'A'..'F' | 'a'..'f' }

identifier = @{ ("#" | "_#")? ~ letter ~ (letter | unicode_digit)* }

decimal_lit = @{ "0" | ("-"? ~ '1'..'9' ~ ( "_"? ~ decimal_digit )*) }
fraction    = @{ decimal_digit ~ ( "_"? ~ decimal_digit )* }
si_lit      = ${ (decimal_lit ~ ("." ~  fraction)? ~ multiplier)
               | ("." ~ fraction ~  multiplier)
               }
binary_lit  = @{ "0b" ~ binary_digit ~ ( "_"? ~ binary_digit )* }
octal_lit   = @{ "0o" ~ octal_digit ~ ( "_"? ~ octal_digit )* }
hex_lit     = @{ "0" ~ ( "x" | "X" ) ~ hex_digit ~ ("_"? ~ hex_digit )* }
multiplier  = @{ ("K" | "M" | "G" | "T" | "P" ) ~ "i"? }
exponent    = ${ ("e" | "E") ~ decimal_lit}

int_lit     = ${ si_lit | decimal_lit  | octal_lit | binary_lit | hex_lit }
float_lit   = ${ (decimal_lit ~ ("." ~ fraction)? ~ exponent?)
               | ("." ~ fraction ~ exponent? )
               }

escape_sequence  = @{ "\\" ~ PEEK[0..1] }
escaped_char     = ${ escape_sequence ~ ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | "/" | "\\" | "'" | "\"" ) }
octal_byte_value = ${ escape_sequence ~ octal_digit{3} }
hex_byte_value   = ${ escape_sequence ~ "x" ~ hex_digit{2} }
little_u_value   = ${ escape_sequence ~ "u" ~ hex_digit{4} }
big_u_value      = ${ escape_sequence ~ "U" ~ hex_digit{8} }
Interpolation    = !{ escape_sequence ~ "(" ~ Expression ~ ")" }
unicode_value    = ${ !(PEEK_ALL | escape_sequence) ~ unicode_char | little_u_value | big_u_value | escaped_char }
byte_value       = ${ octal_byte_value | hex_byte_value }
ending_indent    = @{ (" " | "\t")* }

String       = { PUSH("#"*) ~ ( SimpleString
                              | MultilineString
                              | SimpleBytes
                              | MultilineBytes
                              ) ~ POP }

SimpleString    = ${ !("\""{3}) ~ PUSH("\"") ~ ( Interpolation | unicode_value )* ~ POP }
SimpleBytes     = ${ !("'"{3})  ~ PUSH("'")  ~ ( Interpolation | unicode_value | byte_value )* ~ POP }
MultilineString = ${ PUSH("\"\"\"")
                  ~ "\n"
                  ~ ( !("\n" ~ ending_indent ~ PEEK) ~ (unicode_value | Interpolation | newline) )*
                  ~ "\n"
                  ~ ending_indent ~ POP }
MultilineBytes  = ${ PUSH("'''")
                  ~ "\n"
                  ~ ( !("\n" ~ ending_indent ~ PEEK) ~ (unicode_value | Interpolation | byte_value | newline) )*
                  ~ "\n"
                  ~ ending_indent ~ POP }

bottom_lit = { "_|_" }
null_lit   = { "null" }
bool_lit   = { "true" | "false" }

StructLit       = { "{" ~ ( Declaration ~ "," )* ~ Declaration? ~ "}" }
Declaration     = { Field | Ellipsis | Embedding | attribute }
Ellipsis        = { "..." ~ Expression? }
Embedding       = { Comprehension | AliasExpr }
Field           = { Labels ~ AliasExpr ~ attribute* }
Labels          = { ( Label ~ ":" )+ }
Label           = { ( LabelName ~ "?"? )
                  | ( "[" ~ AliasExpr ~ "]" )
                  | ( "(" ~ Expression ~ ")" )
                  }
LabelName       = { identifier | SimpleString  }

attribute       = { "@" ~ identifier ~ "(" ~ attr_tokens ~ ")" }
attr_tokens     = { ( attr_token
                     | ( "(" ~ attr_tokens ~ ")" )
                     | ( "[" ~ attr_tokens ~ "]" )
                     | ( "{" ~ attr_tokens ~ "}" )
                     )* }
attr_token      = { !( "(" | ")" | "[" | "]" | "{" | "}" ) ~ ANY }

AliasExpr  = { ( identifier ~ "=" )? ~ Expression }

ListLit       = { "[" ~ ( ElementList ~ ","? )? ~ "]" }
ElementList   = { Ellipsis | ( Embedding ~ ( "," ~ Embedding )* ~ ( "," ~ Ellipsis )? ) }

Literal     = { BasicLit | ListLit | StructLit }
Operand     = { Literal | OperandName | ( "(" ~ Expression ~ ")" ) }
BasicLit    = { int_lit | float_lit | String | null_lit | bool_lit | bottom_lit }
OperandName = { identifier | QualifiedIdent }

QualifiedIdent = { PackageName ~ "." ~ identifier }

Selector       = { "." ~ ( identifier | SimpleString ) }
Index          = { "[" ~ Expression ~ "]" }
Slice          = { "[" ~ Expression? ~ ":" ~ Expression? ~ "]" }
Argument       = { Expression }
Arguments      = { "(" ~ ( ( Argument ~ ( "," ~ Argument )* ) ~ ","? )? ~ ")" }

// PrimaryExpr = {	Operand
//               | ( PrimaryExpr ~ Selector )
//               | ( PrimaryExpr ~ Index )
//               | ( PrimaryExpr ~ Slice )
//               | ( PrimaryExpr ~ Arguments )
//               }

PrimaryExpr = { Operand ~ (Selector | Index | Slice | Arguments )* }

UnaryExpr  = { PrimaryExpr | ( unary_op ~ UnaryExpr ) }
// Expression = { UnaryExpr | ( Expression ~ binary_op ~ Expression ) }
Expression = { UnaryExpr ~ (binary_op ~ UnaryExpr)* }


binary_op   = _{ disjunct_op | conjuct_op | or_op | and_op | equal_op | rel_op | add_op | mul_op  }
disjunct_op = { "|" }
conjuct_op  = { "&" }
or_op       = { "||" }
and_op      = { "&&" }
equal_op    = { "==" }
rel_op      = { "!=" | "<" | "<=" | ">" | ">=" | "=~" | "!~" }
add_op      = { "+" | "-" }
mul_op      = { "*" | "/" }
unary_op    = { "!" | "*" | rel_op | add_op }

Comprehension = { Clauses ~ StructLit }

Clauses       = { StartClause ~ ( ","? ~ Clause )* }
StartClause   = { ForClause | GuardClause }
Clause        = { StartClause | LetClause }
ForClause     = { "for" ~ identifier ~ ( "," ~ identifier )? ~ "in" ~ Expression }
GuardClause   = { "if" ~ Expression }
LetClause     = { "let" ~ identifier ~ "=" ~ Expression }

PackageClause = { "package" ~ PackageName }
PackageName   = { identifier }

ImportDecl     = { "import" ~ ( ImportSpec | ("(" ~ ImportSpec* ~ ")") ) }
ImportSpec     = { PackageName? ~ ImportPath }
ImportLocation = { unicode_value* }
ImportPath     = { PUSH("\"") ~ ImportLocation ~ (":" ~ identifier)? ~ POP }

SourceFile = { SOI 
             ~ (attribute ~ ",")*
             ~ (PackageClause)?
             ~ (ImportDecl)*
             ~ (Declaration)*
             ~ EOI
             }

WHITESPACE = _{ " " | "\t" | "\n" }
COMMENT = _{ "//" ~ (!newline ~ ANY)* ~ (newline | EOI) }
